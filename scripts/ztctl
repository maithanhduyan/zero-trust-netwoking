#!/bin/bash
# ==============================================================================
# ZTCTL - Zero Trust Network Control CLI
# Admin tool for managing Zero Trust Network
# ==============================================================================

set -e

ZTCTL_VERSION="1.2.0"
HUB_URL="${HUB_URL:-http://localhost:8000}"
ADMIN_TOKEN="${ADMIN_TOKEN:-change-me-admin-secret}"
CONFIG_FILE="${ZTCTL_CONFIG:-/etc/zerotrust/ztctl.conf}"

[ -f "$CONFIG_FILE" ] && source "$CONFIG_FILE"

# Colors
RED='\033[0;31m'; GREEN='\033[0;32m'; YELLOW='\033[1;33m'
BLUE='\033[0;34m'; CYAN='\033[0;36m'; BOLD='\033[1m'; NC='\033[0m'

print_error() { echo -e "${RED}Error:${NC} $1" >&2; }
print_success() { echo -e "${GREEN}✓${NC} $1"; }
print_info() { echo -e "${BLUE}ℹ${NC} $1"; }

api_call() {
    local method=$1 endpoint=$2 data=$3
    local url="${HUB_URL}/api/v1${endpoint}"
    local args=("-s" "-X" "$method" "-H" "X-Admin-Token: ${ADMIN_TOKEN}" "-H" "Content-Type: application/json")
    [ -n "$data" ] && args+=("-d" "$data")
    curl "${args[@]}" "$url" 2>&1
}

check_jq() { command -v jq &>/dev/null || { print_error "jq required: apt install jq"; exit 1; }; }

# ============= NODE COMMANDS =============
cmd_node() {
    local subcmd=${1:-list}; shift || true
    case "$subcmd" in
        list|ls) node_list "$@" ;;
        show|get) node_show "$@" ;;
        approve) node_approve "$@" ;;
        remove|rm) node_remove "$@" ;;
        *) echo "Usage: ztctl node <list|show|approve|remove>"; exit 1 ;;
    esac
}

node_list() {
    local response=$(api_call GET "/admin/nodes")
    check_jq
    echo -e "\n${CYAN}━━━ REGISTERED NODES ━━━${NC}\n"
    printf "${BOLD}%-4s %-20s %-8s %-15s %-10s${NC}\n" "ID" "HOSTNAME" "ROLE" "OVERLAY IP" "STATUS"
    echo "$response" | jq -r '.nodes // . | .[] | "\(.id)\t\(.hostname)\t\(.role)\t\(.overlay_ip // "N/A")\t\(.status)"' 2>/dev/null | while IFS=$'\t' read -r id hostname role overlay_ip status; do
        case "$status" in
            active) sc="${GREEN}●${NC} active" ;;
            pending) sc="${YELLOW}○${NC} pending" ;;
            *) sc="$status" ;;
        esac
        printf "%-4s %-20s %-8s %-15s %-10b\n" "$id" "$hostname" "$role" "$overlay_ip" "$sc"
    done
    echo ""
}

node_show() { [ -z "$1" ] && { print_error "Usage: ztctl node show <id>"; exit 1; }; api_call GET "/admin/nodes/$1" | jq '.'; }
node_approve() { [ -z "$1" ] && { print_error "Usage: ztctl node approve <id>"; exit 1; }; api_call PATCH "/admin/nodes/$1" '{"status":"active"}'; print_success "Node $1 approved"; }
node_remove() { [ -z "$1" ] && { print_error "Usage: ztctl node remove <id>"; exit 1; }; api_call DELETE "/admin/nodes/$1"; print_success "Node $1 removed"; }

# ============= POLICY COMMANDS =============
cmd_policy() {
    local subcmd=${1:-list}; shift || true
    case "$subcmd" in
        list|ls) policy_list "$@" ;;
        allow) policy_create "allow" "$@" ;;
        deny|block) policy_create "deny" "$@" ;;
        remove|rm) policy_remove "$@" ;;
        *)
            echo "Usage: ztctl policy <list|allow|deny|remove>"
            echo ""
            echo "Examples:"
            echo "  ztctl policy allow app db --port=5432 --protocol=tcp"
            echo "  ztctl policy deny app db --port=22 --protocol=tcp"
            echo "  ztctl policy deny app db --protocol=icmp  # Block ICMP (ping)"
            echo ""
            echo "Note: --port is required (except for ICMP)"
            exit 1
            ;;
    esac
}

policy_list() {
    local response=$(api_call GET "/admin/policies")
    check_jq
    echo -e "\n${CYAN}━━━ ACCESS POLICIES ━━━${NC}\n"
    printf "${BOLD}%-4s %-25s %-8s %-8s %-8s %-6s %-8s${NC}\n" "ID" "NAME" "SRC" "DST" "PROTO" "PORT" "ACTION"
    echo "$response" | jq -r '.policies // . | .[] | "\(.id // "-")\t\(.name)\t\(.src_role // "*")\t\(.dst_role // "*")\t\(.protocol // "any")\t\(.port // "*")\t\(.action)"' 2>/dev/null | while IFS=$'\t' read -r id name src dst proto port action; do
        case "$action" in
            ACCEPT|allow) ac="${GREEN}ACCEPT${NC}" ;;
            DROP|deny) ac="${RED}DROP${NC}" ;;
            REJECT) ac="${RED}REJECT${NC}" ;;
            LOG) ac="${YELLOW}LOG${NC}" ;;
            *) ac="$action" ;;
        esac
        printf "%-4s %-25s %-8s %-8s %-8s %-6s %-8b\n" "$id" "${name:0:25}" "$src" "$dst" "$proto" "$port" "$ac"
    done
    echo ""
}

policy_create() {
    local cli_action=$1 src=$2 dst=$3; shift 3 || { print_error "Usage: ztctl policy $cli_action <src> <dst> --port=X [--protocol=X]"; exit 1; }
    local port="" protocol="tcp" priority=100
    for arg in "$@"; do
        case $arg in
            --port=*) port="${arg#*=}" ;;
            --protocol=*) protocol="${arg#*=}" ;;
            --priority=*) priority="${arg#*=}" ;;
        esac
    done

    # Map allow/deny to API action values
    local api_action
    case "$cli_action" in
        allow) api_action="ACCEPT" ;;
        deny|block) api_action="DROP" ;;
        reject) api_action="REJECT" ;;
        log) api_action="LOG" ;;
        *) api_action="ACCEPT" ;;
    esac

    # For ICMP protocol, port is not needed - use port 0
    if [ "$protocol" = "icmp" ]; then
        port=0
    elif [ -z "$port" ]; then
        print_error "Port is required. Use --port=<port_number>"
        echo "  Example: ztctl policy allow app db --port=5432"
        exit 1
    fi

    local name="${cli_action}-${src}-to-${dst}"
    [ "$port" != "0" ] && name="${name}-${port}"

    local json="{\"name\":\"$name\",\"src_role\":\"$src\",\"dst_role\":\"$dst\",\"protocol\":\"$protocol\",\"port\":$port,\"action\":\"$api_action\",\"priority\":$priority,\"enabled\":true}"
    local response=$(api_call POST "/admin/policies" "$json")
    if echo "$response" | grep -q '"error"'; then
        print_error "$(echo "$response" | jq -r '.error // .detail // .message')"
        [ -n "$ZTCTL_DEBUG" ] && echo "Response: $response"
        exit 1
    fi
    print_success "Policy created: $name"
    echo "  $src → $dst | $protocol:$port | $api_action"
    print_info "Run 'ztctl sync' to apply immediately"
}

policy_remove() { [ -z "$1" ] && { print_error "Usage: ztctl policy remove <id>"; exit 1; }; api_call DELETE "/admin/policies/$1"; print_success "Policy $1 removed"; }

# ============= USER ACCESS MANAGEMENT =============
cmd_user() {
    local subcmd=${1:-list}; shift || true
    case "$subcmd" in
        list|ls) user_list "$@" ;;
        add|create) user_add "$@" ;;
        show|get) user_show "$@" ;;
        groups) user_groups "$@" ;;
        remove|rm|delete) user_delete "$@" ;;
        *)
            echo "Usage: ztctl user <list|add|show|groups|remove>"
            echo ""
            echo "Commands:"
            echo "  list                 List all users"
            echo "  add <user_id>        Create new user"
            echo "  show <user_id>       Show user details"
            echo "  groups <user_id>     Show user's groups"
            echo "  remove <user_id>     Delete user"
            echo ""
            echo "Options for 'add':"
            echo "  --email=<email>      User email"
            echo "  --name=<name>        Display name"
            echo "  --dept=<department>  Department"
            echo ""
            echo "Examples:"
            echo "  ztctl user add john.doe --email=john@example.com --name='John Doe'"
            echo "  ztctl user groups john.doe"
            exit 1
            ;;
    esac
}

user_list() {
    local response=$(api_call GET "/access/users")
    check_jq
    echo -e "\n${CYAN}━━━ USERS ━━━${NC}\n"
    printf "${BOLD}%-4s %-20s %-30s %-15s %-10s${NC}\n" "ID" "USER_ID" "EMAIL" "DEPARTMENT" "STATUS"
    echo "$response" | jq -r '.[] | "\(.id)\t\(.user_id)\t\(.email // "N/A")\t\(.department // "N/A")\t\(.status)"' 2>/dev/null | while IFS=$'\t' read -r id user_id email dept status; do
        case "$status" in
            active) sc="${GREEN}●${NC} active" ;;
            suspended) sc="${YELLOW}○${NC} suspended" ;;
            *) sc="$status" ;;
        esac
        printf "%-4s %-20s %-30s %-15s %-10b\n" "$id" "$user_id" "$email" "$dept" "$sc"
    done
    echo ""
}

user_add() {
    local user_id="$1"; shift || { print_error "Usage: ztctl user add <user_id> [options]"; exit 1; }
    local email="" name="" dept=""

    for arg in "$@"; do
        case $arg in
            --email=*) email="${arg#*=}" ;;
            --name=*) name="${arg#*=}" ;;
            --dept=*) dept="${arg#*=}" ;;
        esac
    done

    local json="{\"user_id\":\"$user_id\""
    [ -n "$email" ] && json="$json,\"email\":\"$email\""
    [ -n "$name" ] && json="$json,\"display_name\":\"$name\""
    [ -n "$dept" ] && json="$json,\"department\":\"$dept\""
    json="$json}"

    local response=$(api_call POST "/access/users" "$json")
    if echo "$response" | grep -qE '"error"|"detail"'; then
        print_error "$(echo "$response" | jq -r '.error // .detail // .message')"
        exit 1
    fi
    print_success "User created: $user_id"
    echo "$response" | jq '.'
}

user_show() {
    [ -z "$1" ] && { print_error "Usage: ztctl user show <user_id>"; exit 1; }
    api_call GET "/access/users/$1" | jq '.'
}

user_groups() {
    [ -z "$1" ] && { print_error "Usage: ztctl user groups <user_id>"; exit 1; }
    local response=$(api_call GET "/access/users/$1/groups")
    check_jq
    echo -e "\n${CYAN}━━━ GROUPS FOR $1 ━━━${NC}\n"
    echo "$response" | jq -r '.groups[] | "  • \(.name) (\(.display_name // .name))"' 2>/dev/null || echo "  No groups"
    echo ""
}

user_delete() {
    [ -z "$1" ] && { print_error "Usage: ztctl user remove <user_id>"; exit 1; }
    api_call DELETE "/access/users/$1"
    print_success "User $1 deleted"
}

# ============= GROUP MANAGEMENT =============
cmd_group() {
    local subcmd=${1:-list}; shift || true
    case "$subcmd" in
        list|ls) group_list "$@" ;;
        add|create) group_add "$@" ;;
        show|get) group_show "$@" ;;
        members) group_members "$@" ;;
        add-member) group_add_member "$@" ;;
        rm-member|remove-member) group_remove_member "$@" ;;
        remove|rm|delete) group_delete "$@" ;;
        *)
            echo "Usage: ztctl group <list|add|show|members|add-member|rm-member|remove>"
            echo ""
            echo "Commands:"
            echo "  list                      List all groups"
            echo "  add <name>                Create new group"
            echo "  show <name>               Show group details"
            echo "  members <name>            List group members"
            echo "  add-member <group> <user> Add user to group"
            echo "  rm-member <group> <user>  Remove user from group"
            echo "  remove <name>             Delete group"
            echo ""
            echo "Examples:"
            echo "  ztctl group add engineering --name='Engineering Team'"
            echo "  ztctl group add-member engineering john.doe"
            exit 1
            ;;
    esac
}

group_list() {
    local response=$(api_call GET "/access/groups")
    check_jq
    echo -e "\n${CYAN}━━━ GROUPS ━━━${NC}\n"
    printf "${BOLD}%-4s %-20s %-30s %-10s${NC}\n" "ID" "NAME" "DISPLAY NAME" "STATUS"
    echo "$response" | jq -r '.[] | "\(.id)\t\(.name)\t\(.display_name // .name)\t\(.status)"' 2>/dev/null | while IFS=$'\t' read -r id name display status; do
        case "$status" in
            active) sc="${GREEN}●${NC} active" ;;
            *) sc="$status" ;;
        esac
        printf "%-4s %-20s %-30s %-10b\n" "$id" "$name" "$display" "$sc"
    done
    echo ""
}

group_add() {
    local name="$1"; shift || { print_error "Usage: ztctl group add <name> [options]"; exit 1; }
    local display="" desc=""

    for arg in "$@"; do
        case $arg in
            --name=*|--display=*) display="${arg#*=}" ;;
            --desc=*) desc="${arg#*=}" ;;
        esac
    done

    local json="{\"name\":\"$name\""
    [ -n "$display" ] && json="$json,\"display_name\":\"$display\""
    [ -n "$desc" ] && json="$json,\"description\":\"$desc\""
    json="$json}"

    local response=$(api_call POST "/access/groups" "$json")
    if echo "$response" | grep -qE '"error"|"detail"'; then
        print_error "$(echo "$response" | jq -r '.error // .detail // .message')"
        exit 1
    fi
    print_success "Group created: $name"
}

group_show() {
    [ -z "$1" ] && { print_error "Usage: ztctl group show <name>"; exit 1; }
    api_call GET "/access/groups/$1" | jq '.'
}

group_members() {
    [ -z "$1" ] && { print_error "Usage: ztctl group members <name>"; exit 1; }
    local response=$(api_call GET "/access/groups/$1/members")
    check_jq
    echo -e "\n${CYAN}━━━ MEMBERS OF $1 ━━━${NC}\n"
    echo "$response" | jq -r '.members[] | "  • \(.user_id) (\(.display_name // .user_id))"' 2>/dev/null || echo "  No members"
    echo ""
}

group_add_member() {
    [ -z "$1" ] || [ -z "$2" ] && { print_error "Usage: ztctl group add-member <group> <user_id>"; exit 1; }
    local response=$(api_call POST "/access/groups/$1/members" "{\"user_id\":\"$2\"}")
    if echo "$response" | grep -q '"success": true'; then
        print_success "Added $2 to group $1"
    else
        print_error "$(echo "$response" | jq -r '.detail // .error // .message')"
        exit 1
    fi
}

group_remove_member() {
    [ -z "$1" ] || [ -z "$2" ] && { print_error "Usage: ztctl group rm-member <group> <user_id>"; exit 1; }
    api_call DELETE "/access/groups/$1/members/$2"
    print_success "Removed $2 from group $1"
}

group_delete() {
    [ -z "$1" ] && { print_error "Usage: ztctl group remove <name>"; exit 1; }
    api_call DELETE "/access/groups/$1"
    print_success "Group $1 deleted"
}

# ============= ACCESS POLICY COMMANDS =============
cmd_access() {
    local subcmd=${1:-list}; shift || true
    case "$subcmd" in
        list|ls) access_list "$@" ;;
        add|create) access_add "$@" ;;
        show|get) access_show "$@" ;;
        remove|rm|delete) access_remove "$@" ;;
        eval|evaluate|check) access_eval "$@" ;;
        *)
            echo "Usage: ztctl access <list|add|show|remove|eval>"
            echo ""
            echo "Commands:"
            echo "  list                   List all access policies"
            echo "  add [options]          Create access policy"
            echo "  show <id>              Show policy details"
            echo "  remove <id>            Delete policy"
            echo "  eval <user> <domain>   Evaluate access for user"
            echo ""
            echo "Options for 'add':"
            echo "  --name=<name>          Policy name (required)"
            echo "  --subject=<type:id>    Subject (user:john.doe, group:engineering, all)"
            echo "  --resource=<type:val>  Resource (domain:*.example.com, ip_range:10.0.0.0/24)"
            echo "  --action=<action>      allow, deny, require_mfa (default: allow)"
            echo "  --priority=<num>       Priority (lower = higher) default: 100"
            echo ""
            echo "Examples:"
            echo "  ztctl access add --name=eng-internal --subject=group:engineering --resource=domain:*.internal.com --action=allow"
            echo "  ztctl access add --name=deny-prod --subject=user:intern --resource=domain:*.prod.com --action=deny --priority=50"
            echo "  ztctl access eval john.doe api.internal.example.com"
            exit 1
            ;;
    esac
}

access_list() {
    local response=$(api_call GET "/access/policies")
    check_jq
    echo -e "\n${CYAN}━━━ ACCESS POLICIES ━━━${NC}\n"
    printf "${BOLD}%-4s %-25s %-12s %-25s %-8s %-5s${NC}\n" "ID" "NAME" "SUBJECT" "RESOURCE" "ACTION" "PRI"
    echo "$response" | jq -r '.[] | "\(.id)\t\(.name)\t\(.subject_type):\(.subject_id // "*")\t\(.resource_type):\(.resource_value)\t\(.action)\t\(.priority)"' 2>/dev/null | while IFS=$'\t' read -r id name subject resource action pri; do
        case "$action" in
            allow) ac="${GREEN}allow${NC}" ;;
            deny) ac="${RED}deny${NC}" ;;
            require_mfa) ac="${YELLOW}mfa${NC}" ;;
            *) ac="$action" ;;
        esac
        printf "%-4s %-25s %-12s %-25s %-8b %-5s\n" "$id" "${name:0:25}" "${subject:0:12}" "${resource:0:25}" "$ac" "$pri"
    done
    echo ""
}

access_add() {
    local name="" subject_type="" subject_id="" resource_type="" resource_value="" action="allow" priority=100

    for arg in "$@"; do
        case $arg in
            --name=*) name="${arg#*=}" ;;
            --subject=*)
                local subj="${arg#*=}"
                subject_type="${subj%%:*}"
                subject_id="${subj#*:}"
                [ "$subject_type" = "all" ] && subject_id=""
                ;;
            --resource=*)
                local res="${arg#*=}"
                resource_type="${res%%:*}"
                resource_value="${res#*:}"
                ;;
            --action=*) action="${arg#*=}" ;;
            --priority=*) priority="${arg#*=}" ;;
        esac
    done

    [ -z "$name" ] && { print_error "Policy name is required (--name=...)"; exit 1; }
    [ -z "$subject_type" ] && { print_error "Subject is required (--subject=user:X or group:X or all)"; exit 1; }
    [ -z "$resource_type" ] && { print_error "Resource is required (--resource=domain:X or ip_range:X)"; exit 1; }

    # Build JSON - need to lookup subject_id if it's a name
    local json="{\"name\":\"$name\",\"subject_type\":\"$subject_type\",\"resource_type\":\"$resource_type\",\"resource_value\":\"$resource_value\",\"action\":\"$action\",\"priority\":$priority"

    if [ "$subject_type" = "user" ] && [ -n "$subject_id" ]; then
        # Get user ID
        local user_info=$(api_call GET "/access/users/$subject_id")
        local user_db_id=$(echo "$user_info" | jq -r '.id // empty')
        [ -z "$user_db_id" ] && { print_error "User $subject_id not found"; exit 1; }
        json="$json,\"subject_id\":$user_db_id"
    elif [ "$subject_type" = "group" ] && [ -n "$subject_id" ]; then
        # Get group ID
        local group_info=$(api_call GET "/access/groups/$subject_id")
        local group_db_id=$(echo "$group_info" | jq -r '.id // empty')
        [ -z "$group_db_id" ] && { print_error "Group $subject_id not found"; exit 1; }
        json="$json,\"subject_id\":$group_db_id"
    fi

    json="$json}"

    local response=$(api_call POST "/access/policies" "$json")
    if echo "$response" | grep -qE '"error"|"detail"'; then
        print_error "$(echo "$response" | jq -r '.error // .detail // .message')"
        exit 1
    fi
    print_success "Access policy created: $name"
    echo "  Subject: $subject_type:$subject_id"
    echo "  Resource: $resource_type:$resource_value"
    echo "  Action: $action (priority: $priority)"
}

access_show() {
    [ -z "$1" ] && { print_error "Usage: ztctl access show <id>"; exit 1; }
    api_call GET "/access/policies/$1" | jq '.'
}

access_remove() {
    [ -z "$1" ] && { print_error "Usage: ztctl access remove <id>"; exit 1; }
    api_call DELETE "/access/policies/$1"
    print_success "Access policy $1 deleted"
}

access_eval() {
    [ -z "$1" ] || [ -z "$2" ] && { print_error "Usage: ztctl access eval <user_id> <domain>"; exit 1; }
    local response=$(api_call POST "/access/evaluate" "{\"user_id\":\"$1\",\"resource_type\":\"domain\",\"resource_value\":\"$2\"}")
    check_jq

    local allowed=$(echo "$response" | jq -r '.allowed')
    local action=$(echo "$response" | jq -r '.action')
    local reason=$(echo "$response" | jq -r '.reason')

    if [ "$allowed" = "true" ]; then
        echo -e "${GREEN}✓ ALLOWED${NC} - $1 can access $2"
    else
        echo -e "${RED}✗ DENIED${NC} - $1 cannot access $2"
    fi
    echo "  Action: $action"
    echo "  Reason: $reason"
}

# ============= CLIENT COMMANDS (Mobile/Laptop VPN) =============
cmd_client() {
    local subcmd=${1:-list}; shift || true
    case "$subcmd" in
        list|ls) client_list "$@" ;;
        add|create) client_add "$@" ;;
        show|get) client_show "$@" ;;
        config) client_config "$@" ;;
        qr) client_qr "$@" ;;
        revoke|rm|remove) client_revoke "$@" ;;
        *)
            echo "Usage: ztctl client <list|add|show|config|qr|revoke>"
            echo ""
            echo "Commands:"
            echo "  list                    List all client devices"
            echo "  add <name>              Create new client device"
            echo "  show <id>               Show device details"
            echo "  config <id>             Show WireGuard config"
            echo "  qr <id>                 Generate QR code (terminal)"
            echo "  revoke <id>             Revoke device access"
            echo ""
            echo "Options for 'add':"
            echo "  --type=<mobile|laptop|desktop>   Device type (default: mobile)"
            echo "  --user=<email>                   Owner user ID"
            echo "  --tunnel=<full|split>            Tunnel mode (default: full)"
            echo "  --expires=<days>                 Expiration days (default: 30)"
            echo ""
            echo "Examples:"
            echo "  ztctl client add iPhone-John --type=mobile --user=john@company.com"
            echo "  ztctl client add MacBook-Work --type=laptop --tunnel=full --expires=90"
            echo "  ztctl client qr 1"
            exit 1
            ;;
    esac
}

client_list() {
    local user_filter=""
    for arg in "$@"; do
        case $arg in
            --user=*) user_filter="?user_id=${arg#*=}" ;;
        esac
    done

    local response=$(api_call GET "/client/devices${user_filter}")
    check_jq
    echo -e "\n${CYAN}━━━ CLIENT DEVICES (Mobile/Laptop VPN) ━━━${NC}\n"
    printf "${BOLD}%-4s %-18s %-8s %-18s %-15s %-8s${NC}\n" "ID" "NAME" "TYPE" "USER" "OVERLAY IP" "STATUS"
    echo "$response" | jq -r '.devices // . | .[] | "\(.id)\t\(.device_name)\t\(.device_type)\t\(.user_id // "N/A")\t\(.overlay_ip)\t\(.status)"' 2>/dev/null | while IFS=$'\t' read -r id name dtype user ip status; do
        case "$status" in
            active) sc="${GREEN}●${NC} active" ;;
            revoked) sc="${RED}×${NC} revoked" ;;
            *) sc="$status" ;;
        esac
        printf "%-4s %-18s %-8s %-18s %-15s %-10b\n" "$id" "${name:0:18}" "$dtype" "${user:0:18}" "${ip%/*}" "$sc"
    done
    echo ""
}

client_add() {
    local name="$1"; shift || { print_error "Usage: ztctl client add <name> [options]"; exit 1; }
    local dtype="mobile" user="" tunnel="full" expires=30 desc=""

    for arg in "$@"; do
        case $arg in
            --type=*) dtype="${arg#*=}" ;;
            --user=*) user="${arg#*=}" ;;
            --tunnel=*) tunnel="${arg#*=}" ;;
            --expires=*) expires="${arg#*=}" ;;
            --desc=*) desc="${arg#*=}" ;;
        esac
    done

    local json="{\"device_name\":\"$name\",\"device_type\":\"$dtype\",\"tunnel_mode\":\"$tunnel\",\"expires_days\":$expires"
    [ -n "$user" ] && json="$json,\"user_id\":\"$user\""
    [ -n "$desc" ] && json="$json,\"description\":\"$desc\""
    json="$json}"

    local response=$(api_call POST "/client/devices" "$json")
    if echo "$response" | grep -q '"error"'; then
        print_error "$(echo "$response" | jq -r '.detail.error // .error // .message')"
        exit 1
    fi

    local id=$(echo "$response" | jq -r '.id')
    local ip=$(echo "$response" | jq -r '.overlay_ip')
    local token=$(echo "$response" | jq -r '.config_token')
    local expires_at=$(echo "$response" | jq -r '.expires_at')

    print_success "Client device created: $name (ID: $id)"
    echo -e "  Type:       $dtype"
    echo -e "  Overlay IP: $ip"
    echo -e "  Tunnel:     $tunnel ($([ "$tunnel" = "full" ] && echo "all traffic via VPN" || echo "overlay only"))"
    echo -e "  Expires:    ${expires_at:0:10}"
    echo ""
    echo -e "${YELLOW}Config download URL:${NC}"
    echo "  ${HUB_URL}/api/v1/client/config/$token"
    echo ""
    echo -e "${YELLOW}QR code URL (for mobile):${NC}"
    echo "  ${HUB_URL}/api/v1/client/config/$token/qr"
    echo ""
    print_info "Run 'ztctl client qr $id' to show QR in terminal"
}

client_show() {
    [ -z "$1" ] && { print_error "Usage: ztctl client show <id>"; exit 1; }
    api_call GET "/client/devices/$1" | jq '.'
}

client_config() {
    [ -z "$1" ] && { print_error "Usage: ztctl client config <id>"; exit 1; }

    # Get device to find token
    local device=$(api_call GET "/client/devices/$1")
    local token=$(echo "$device" | jq -r '.config_token // empty')

    if [ -z "$token" ]; then
        print_error "No config token found. Device may be revoked."
        exit 1
    fi

    echo -e "\n${CYAN}━━━ WIREGUARD CONFIG ━━━${NC}\n"
    curl -s "${HUB_URL}/api/v1/client/config/$token/raw"
    echo -e "\n"
}

client_qr() {
    [ -z "$1" ] && { print_error "Usage: ztctl client qr <id>"; exit 1; }

    # Check if qrencode is installed
    if ! command -v qrencode &>/dev/null; then
        print_info "Install qrencode for terminal QR: apt install qrencode"
        echo ""

        # Fallback: show URL
        local device=$(api_call GET "/client/devices/$1")
        local token=$(echo "$device" | jq -r '.config_token // empty')
        local name=$(echo "$device" | jq -r '.device_name')

        if [ -n "$token" ]; then
            echo -e "${YELLOW}Open this URL on mobile to scan QR:${NC}"
            echo "  ${HUB_URL}/api/v1/client/config/$token/qr"
            echo ""
            echo -e "${YELLOW}Or download config file:${NC}"
            echo "  ${HUB_URL}/api/v1/client/config/$token/raw"
        fi
        exit 0
    fi

    # Get config and generate QR in terminal
    local device=$(api_call GET "/client/devices/$1")
    local token=$(echo "$device" | jq -r '.config_token // empty')
    local name=$(echo "$device" | jq -r '.device_name')

    if [ -z "$token" ]; then
        print_error "No config token found. Device may be revoked."
        exit 1
    fi

    local config=$(curl -s "${HUB_URL}/api/v1/client/config/$token/raw")

    echo -e "\n${CYAN}━━━ QR CODE: $name ━━━${NC}\n"
    echo "$config" | qrencode -t ANSIUTF8
    echo -e "\n${GREEN}Scan with WireGuard app on mobile${NC}\n"
}

client_revoke() {
    [ -z "$1" ] && { print_error "Usage: ztctl client revoke <id>"; exit 1; }

    local response=$(api_call DELETE "/client/devices/$1")
    if echo "$response" | grep -q '"success":true'; then
        print_success "Device $1 revoked"
    else
        print_error "$(echo "$response" | jq -r '.detail.error // .error // .message')"
        exit 1
    fi
}

# ============= PEER COMMANDS =============
cmd_peer() {
    local subcmd=${1:-list}; shift || true
    case "$subcmd" in
        list|ls) peer_list ;;
        add) peer_add "$@" ;;
        remove|rm) peer_remove "$@" ;;
        *) echo "Usage: ztctl peer <list|add|remove>"; exit 1 ;;
    esac
}

peer_list() {
    local response=$(api_call GET "/admin/wireguard/peers")
    check_jq
    echo -e "\n${CYAN}━━━ WIREGUARD PEERS ━━━${NC}\n"
    printf "${BOLD}%-46s %-18s %-22s${NC}\n" "PUBLIC KEY" "ALLOWED IPS" "ENDPOINT"
    echo "$response" | jq -r '.peers[] | "\(.public_key)\t\(.allowed_ips)\t\(.endpoint // "N/A")"' 2>/dev/null | while IFS=$'\t' read -r pk ip ep; do
        printf "%-46s %-18s %-22s\n" "${pk:0:44}.." "$ip" "${ep:0:22}"
    done
    echo ""
}

peer_add() {
    [ -z "$1" ] || [ -z "$2" ] && { print_error "Usage: ztctl peer add <pubkey> <allowed_ips>"; exit 1; }
    api_call POST "/admin/wireguard/add-peer" "{\"public_key\":\"$1\",\"allowed_ips\":\"$2\"}"
    print_success "Peer added: $2"
}

peer_remove() {
    [ -z "$1" ] && { print_error "Usage: ztctl peer remove <pubkey>"; exit 1; }
    api_call DELETE "/admin/wireguard/peers/$(echo -n "$1" | jq -sRr @uri)"
    print_success "Peer removed"
}

# ============= SYNC COMMAND =============
cmd_sync() {
    echo -e "\n${CYAN}━━━ TRIGGERING POLICY SYNC ━━━${NC}\n"
    local response=$(api_call POST "/admin/policies/sync" '{"force":true}')
    if echo "$response" | grep -q '"error"'; then
        print_info "Sync API not implemented. Agents auto-sync in 60s."
        echo "  Force on node: systemctl restart zero-trust-agent"
    else
        print_success "Sync triggered"
    fi
    echo ""
}

# ============= STATUS COMMAND =============
cmd_status() {
    echo -e "\n${CYAN}╔══════════════════════════════════════════════════════════════╗${NC}"
    echo -e "${CYAN}║              ZERO TRUST CLUSTER STATUS                       ║${NC}"
    echo -e "${CYAN}╚══════════════════════════════════════════════════════════════╝${NC}\n"

    echo -e "${BOLD}Hub API:${NC} $HUB_URL"
    local health=$(curl -s --max-time 3 "${HUB_URL}/health" 2>/dev/null)
    if echo "$health" | grep -q '"status"'; then
        echo -e "  Status: ${GREEN}● Online${NC}"
    else
        echo -e "  Status: ${RED}● Offline${NC}"
    fi

    echo -e "\n${BOLD}WireGuard:${NC}"
    if wg show wg0 &>/dev/null; then
        echo -e "  Status: ${GREEN}● Running${NC}"
        echo "  Peers:  $(wg show wg0 peers | wc -l)"
    else
        echo -e "  Status: ${YELLOW}○ Not local${NC}"
    fi

    echo -e "\n${BOLD}Server Nodes:${NC}"
    local nodes=$(api_call GET "/admin/nodes" 2>/dev/null)
    check_jq
    local total=$(echo "$nodes" | jq '.nodes // . | length' 2>/dev/null || echo 0)
    local active=$(echo "$nodes" | jq '[(.nodes // .)[] | select(.status=="active")] | length' 2>/dev/null || echo 0)
    echo "  Total: $total | Active: $active"

    echo -e "\n${BOLD}Client Devices (VPN):${NC}"
    local clients=$(api_call GET "/client/devices" 2>/dev/null)
    local client_total=$(echo "$clients" | jq '.devices // . | length' 2>/dev/null || echo 0)
    local client_active=$(echo "$clients" | jq '[(.devices // .)[] | select(.status=="active")] | length' 2>/dev/null || echo 0)
    echo "  Total: $client_total | Active: $client_active"
    echo ""
}

# ============= HELP =============
show_help() {
    cat << 'EOF'
ZTCTL - Zero Trust Network Control CLI (v1.2.0)

USAGE:
    ztctl <command> [subcommand] [options]

COMMANDS:
    node        Manage server nodes (list, show, approve, remove)
    client      Manage client devices - mobile/laptop VPN (list, add, config, qr, revoke)
    policy      Manage network policies (list, allow, deny, remove)
    user        Manage users (list, add, show, groups, remove)
    group       Manage groups (list, add, members, add-member, remove)
    access      Manage access policies (list, add, eval, remove)
    peer        Manage WireGuard peers (list, add, remove)
    sync        Trigger policy sync to all nodes
    status      Show cluster status
    help        Show this help

USER COMMANDS:
    ztctl user list                     List all users
    ztctl user add <user_id> [options]  Create new user
        --email=<email>                 User email
        --name=<name>                   Display name
        --dept=<department>             Department
    ztctl user show <user_id>           Show user details
    ztctl user groups <user_id>         Show user's groups
    ztctl user remove <user_id>         Delete user

GROUP COMMANDS:
    ztctl group list                    List all groups
    ztctl group add <name> [options]    Create new group
    ztctl group members <name>          List group members
    ztctl group add-member <grp> <user> Add user to group
    ztctl group rm-member <grp> <user>  Remove user from group
    ztctl group remove <name>           Delete group

ACCESS POLICY COMMANDS:
    ztctl access list                   List access policies
    ztctl access add [options]          Create access policy
        --name=<name>                   Policy name (required)
        --subject=<type:id>             user:X, group:X, or all
        --resource=<type:value>         domain:*.example.com, ip_range:10.0.0.0/24
        --action=<allow|deny|require_mfa>
        --priority=<num>                Lower = higher priority
    ztctl access eval <user> <domain>   Test if user can access domain
    ztctl access remove <id>            Delete policy

NODE COMMANDS:
    ztctl node list                     List all nodes
    ztctl node show <id>                Show node details
    ztctl node approve <id>             Approve pending node
    ztctl node remove <id>              Remove node

CLIENT COMMANDS (Mobile/Laptop VPN):
    ztctl client list                   List all client devices
    ztctl client add <name> [options]   Create new device
        --type=<mobile|laptop|desktop>  Device type (default: mobile)
        --user=<email>                  Owner user ID
        --tunnel=<full|split>           Tunnel mode (default: full)
        --expires=<days>                Expiration days (default: 30)
    ztctl client show <id>              Show device details
    ztctl client config <id>            Show WireGuard config
    ztctl client qr <id>                Generate QR code in terminal
    ztctl client revoke <id>            Revoke device access

POLICY COMMANDS (Network ACL):
    ztctl policy list                   List all policies
    ztctl policy allow <src> <dst> --port=X --protocol=tcp
    ztctl policy deny <src> <dst> --port=X --protocol=tcp
    ztctl policy remove <id>            Remove policy

EXAMPLES:
    # User/Group management
    ztctl user add john.doe --email=john@example.com --name='John Doe'
    ztctl group add engineering --name='Engineering Team'
    ztctl group add-member engineering john.doe

    # Access policies
    ztctl access add --name=eng-internal --subject=group:engineering --resource=domain:*.internal.com
    ztctl access eval john.doe api.internal.example.com

    # Client VPN devices
    ztctl client add iPhone-John --type=mobile --user=john.doe
    ztctl client qr 1

ENVIRONMENT:
    HUB_URL       Hub API URL (default: http://localhost:8000)
    ADMIN_TOKEN   Admin authentication token
EOF
}

# ============= MAIN =============
case "${1:-help}" in
    node|nodes) shift; cmd_node "$@" ;;
    client|clients|vpn) shift; cmd_client "$@" ;;
    policy|pol) shift; cmd_policy "$@" ;;
    user|users) shift; cmd_user "$@" ;;
    group|groups) shift; cmd_group "$@" ;;
    access|acl) shift; cmd_access "$@" ;;
    peer|peers) shift; cmd_peer "$@" ;;
    sync) shift; cmd_sync "$@" ;;
    status|st) cmd_status ;;
    help|--help|-h) show_help ;;
    version|-v) echo "ztctl $ZTCTL_VERSION" ;;
    *) print_error "Unknown: $1"; echo "Run 'ztctl help'"; exit 1 ;;
esac