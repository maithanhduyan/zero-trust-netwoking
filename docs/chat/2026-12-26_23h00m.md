**User:**
Thiết kế chức năng control-plane register để ansible playbook và wireguard tạo Overlay IP cho client

**AI:**
User: Thiết kế chức năng control-plane `register` để ansible playbook và wireguard tạo `Overlay IP` cho client

GitHub Copilot: # Thiết kế chức năng Control-Plane `register` cho WireGuard Overlay Network

## Tổng quan kiến trúc

Chức năng `register` là điểm khởi đầu của Zero Trust workflow, nơi Agent trên mỗi VPS đăng ký với Control Plane để nhận:
1. **Overlay IP** (VD: `10.0.0.2/24`)
2. **WireGuard Configuration** (Server endpoint, Public keys)
3. **ACL Rules** (Firewall rules dựa trên Role)

```
┌─────────────────────────────────────────────────────────────────┐
│                        CONTROL PLANE (VPS-1)                    │
│  ┌──────────────┐    ┌──────────────┐    ┌──────────────────┐  │
│  │   FastAPI    │───▶│ IPAM Service │───▶│  PostgreSQL DB   │  │
│  │  /register   │    │  (10.0.0.x)  │    │ (nodes, peers)   │  │
│  └──────────────┘    └──────────────┘    └──────────────────┘  │
│         │                                         │             │
│         ▼                                         ▼             │
│  ┌──────────────┐                      ┌──────────────────┐    │
│  │Policy Engine │                      │  WireGuard Hub   │    │
│  │ (ACL Rules)  │                      │   (wg0 10.0.0.1) │    │
│  └──────────────┘                      └──────────────────┘    │
└─────────────────────────────────────────────────────────────────┘
         │
         │ HTTPS/mTLS
         ▼
┌─────────────────────┐  ┌─────────────────────┐
│   VPS-2 (Agent)     │  │   VPS-3 (Agent)     │
│   Role: app         │  │   Role: db          │
│   IP: 10.0.0.2      │  │   IP: 10.0.0.3      │
└─────────────────────┘  └─────────────────────┘
```

---

## 1. Database Schema

````python
from sqlalchemy import Column, Integer, String, Boolean, DateTime, Text, Enum
from sqlalchemy.orm import declarative_base
from datetime import datetime
import enum

Base = declarative_base()

class NodeStatus(str, enum.Enum):
    PENDING = "pending"      # Chờ approve
    ACTIVE = "active"        # Đang hoạt động
    SUSPENDED = "suspended"  # Tạm ngưng
    REVOKED = "revoked"      # Bị thu hồi

class NodeRole(str, enum.Enum):
    HUB = "hub"        # Control Plane / WireGuard Server
    APP = "app"        # Application servers (Odoo, Web...)
    DB = "db"          # Database servers (PostgreSQL...)
    OPS = "ops"        # Operations / Admin access
    MONITOR = "monitor" # Monitoring systems

class Node(Base):
    """
    Bảng lưu trữ thông tin các node trong mạng Zero Trust
    """
    __tablename__ = "nodes"

    id = Column(Integer, primary_key=True, index=True)

    # Thông tin định danh
    hostname = Column(String(255), unique=True, nullable=False, index=True)
    role = Column(String(50), nullable=False)  # app, db, ops, hub
    description = Column(Text, nullable=True)

    # WireGuard Keys
    public_key = Column(String(44), unique=True, nullable=False)  # Base64 WG key = 44 chars
    preshared_key = Column(String(44), nullable=True)  # Optional PSK for extra security

    # Network
    overlay_ip = Column(String(18), unique=True, nullable=False)  # 10.0.0.x/24
    real_ip = Column(String(45), nullable=True)  # IPv4/IPv6 public IP
    listen_port = Column(Integer, default=51820)

    # Status & Metadata
    status = Column(String(20), default=NodeStatus.PENDING.value)
    registration_token = Column(String(64), nullable=True)  # One-time token for registration

    # Timestamps
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    last_seen = Column(DateTime, nullable=True)

    # Agent version tracking
    agent_version = Column(String(20), nullable=True)
    os_info = Column(String(100), nullable=True)


class IPAllocation(Base):
    """
    Bảng quản lý IP Pool - tách riêng để dễ mở rộng nhiều subnet
    """
    __tablename__ = "ip_allocations"

    id = Column(Integer, primary_key=True)
    network_cidr = Column(String(18), nullable=False)  # 10.0.0.0/24
    ip_address = Column(String(15), unique=True, nullable=False)
    node_id = Column(Integer, nullable=True)  # NULL = available
    allocated_at = Column(DateTime, nullable=True)
````

---

## 2. Pydantic Schemas

````python
from pydantic import BaseModel, Field, field_validator
from typing import Optional, List
from datetime import datetime
from enum import Enum
import re

class NodeRole(str, Enum):
    HUB = "hub"
    APP = "app"
    DB = "db"
    OPS = "ops"
    MONITOR = "monitor"

class NodeStatus(str, Enum):
    PENDING = "pending"
    ACTIVE = "active"
    SUSPENDED = "suspended"
    REVOKED = "revoked"

# --- Request Schemas ---

class NodeRegisterRequest(BaseModel):
    """
    Schema cho request đăng ký node mới
    Agent gửi thông tin này khi bootstrap lần đầu
    """
    hostname: str = Field(..., min_length=3, max_length=255, examples=["odoo-prod-01"])
    role: NodeRole = Field(..., examples=["app"])
    public_key: str = Field(..., min_length=44, max_length=44, examples=["aB3dE5fG7hI9jK1lM3nO5pQ7rS9tU1vW3xY5zA7bC9d="])
    registration_token: Optional[str] = Field(None, min_length=32, max_length=64)

    # Optional metadata
    description: Optional[str] = None
    agent_version: Optional[str] = Field(None, examples=["1.0.0"])
    os_info: Optional[str] = Field(None, examples=["Ubuntu 22.04 LTS"])

    @field_validator('public_key')
    @classmethod
    def validate_wireguard_key(cls, v: str) -> str:
        """Validate WireGuard public key format (Base64, 44 chars)"""
        if not re.match(r'^[A-Za-z0-9+/]{43}=$', v):
            raise ValueError('Invalid WireGuard public key format')
        return v

    @field_validator('hostname')
    @classmethod
    def validate_hostname(cls, v: str) -> str:
        """Validate hostname format"""
        if not re.match(r'^[a-z0-9]([a-z0-9\-]*[a-z0-9])?$', v.lower()):
            raise ValueError('Hostname must be lowercase alphanumeric with optional hyphens')
        return v.lower()


# --- Response Schemas ---

class WireGuardPeer(BaseModel):
    """Thông tin một peer trong mạng WireGuard"""
    public_key: str
    allowed_ips: str
    endpoint: Optional[str] = None  # Only for hub
    persistent_keepalive: int = 25

class FirewallRule(BaseModel):
    """Luật firewall (iptables/nftables)"""
    src_ip: str
    dst_port: int
    protocol: str = "tcp"
    action: str = "ACCEPT"
    comment: Optional[str] = None

class NodeRegisterResponse(BaseModel):
    """
    Response trả về cho Agent sau khi đăng ký thành công
    Chứa đầy đủ thông tin để Agent cấu hình WireGuard
    """
    # Node identity
    node_id: int
    hostname: str
    status: NodeStatus

    # Assigned network config
    overlay_ip: str = Field(..., examples=["10.0.0.2/24"])

    # WireGuard server config (Hub)
    server_public_key: str
    server_endpoint: str = Field(..., examples=["hub.example.com:51820"])

    # DNS & Routing
    dns_servers: List[str] = Field(default=["10.0.0.1"])
    allowed_ips: str = Field(default="10.0.0.0/24")

    # Message
    message: str = Field(default="Registration successful")

    class Config:
        from_attributes = True


class NodeConfigResponse(BaseModel):
    """
    Response đầy đủ khi Agent gọi /sync hoặc /config
    Bao gồm cả danh sách peers và ACL rules
    """
    # Basic info
    node_id: int
    hostname: str
    overlay_ip: str
    status: NodeStatus

    # WireGuard config
    interface: dict  # [Interface] section
    peers: List[WireGuardPeer]  # [Peer] sections

    # Firewall rules (Zero Trust ACLs)
    acl_rules: List[FirewallRule]

    # Metadata
    config_version: int  # Để Agent biết config có thay đổi không
    generated_at: datetime
````

---

## 3. IPAM Service (IP Address Management)

````python
import ipaddress
from typing import Optional
from sqlalchemy.orm import Session
from database.models import Node, IPAllocation
import logging

logger = logging.getLogger(__name__)

class IPAMService:
    """
    Quản lý cấp phát IP trong Overlay Network
    Tuân thủ nguyên tắc: Mỗi node có duy nhất 1 IP, IP không được tái sử dụng ngay
    """

    def __init__(self, network_cidr: str = "10.0.0.0/24"):
        self.network = ipaddress.IPv4Network(network_cidr, strict=False)
        self.network_cidr = network_cidr

        # Reserved IPs
        self.reserved_ips = {
            str(self.network.network_address),      # 10.0.0.0 - Network
            str(self.network.broadcast_address),    # 10.0.0.255 - Broadcast
            str(list(self.network.hosts())[0]),     # 10.0.0.1 - Hub/Gateway
        }

    def initialize_pool(self, db: Session) -> None:
        """
        Khởi tạo IP Pool trong database (Chạy 1 lần khi setup)
        """
        existing = db.query(IPAllocation).filter(
            IPAllocation.network_cidr == self.network_cidr
        ).first()

        if existing:
            logger.info(f"IP Pool {self.network_cidr} already initialized")
            return

        logger.info(f"Initializing IP Pool: {self.network_cidr}")

        for ip in self.network.hosts():
            ip_str = str(ip)
            if ip_str in self.reserved_ips:
                continue

            allocation = IPAllocation(
                network_cidr=self.network_cidr,
                ip_address=ip_str,
                node_id=None
            )
            db.add(allocation)

        db.commit()
        logger.info(f"Created {self.network.num_addresses - len(self.reserved_ips)} allocatable IPs")

    def allocate_ip(self, db: Session, node_id: int) -> Optional[str]:
        """
        Cấp phát IP mới cho node
        Returns: IP address with CIDR (e.g., "10.0.0.2/24") hoặc None nếu hết IP
        """
        # Tìm IP chưa được cấp phát
        available = db.query(IPAllocation).filter(
            IPAllocation.network_cidr == self.network_cidr,
            IPAllocation.node_id.is_(None)
        ).order_by(IPAllocation.ip_address).first()

        if not available:
            logger.error("IP Pool exhausted!")
            return None

        # Đánh dấu IP đã được sử dụng
        available.node_id = node_id
        available.allocated_at = datetime.utcnow()
        db.commit()

        # Trả về IP kèm prefix length
        prefix_len = self.network.prefixlen
        return f"{available.ip_address}/{prefix_len}"

    def release_ip(self, db: Session, node_id: int) -> bool:
        """
        Giải phóng IP khi node bị xóa hoặc revoke
        """
        allocation = db.query(IPAllocation).filter(
            IPAllocation.node_id == node_id
        ).first()

        if allocation:
            allocation.node_id = None
            allocation.allocated_at = None
            db.commit()
            return True
        return False

    def get_node_ip(self, db: Session, node_id: int) -> Optional[str]:
        """
        Lấy IP đã cấp cho node
        """
        allocation = db.query(IPAllocation).filter(
            IPAllocation.node_id == node_id
        ).first()

        if allocation:
            return f"{allocation.ip_address}/{self.network.prefixlen}"
        return None


# Singleton instance
from datetime import datetime
ipam_service = IPAMService()
````

---

## 4. Registration Service

````python
from typing import Optional, Tuple
from sqlalchemy.orm import Session
from sqlalchemy.exc import IntegrityError
from datetime import datetime
import logging
import secrets

from database.models import Node, NodeStatus
from schemas.node import NodeRegisterRequest, NodeRegisterResponse, NodeStatus as SchemaNodeStatus
from core.ipam import ipam_service
from core.config import settings

logger = logging.getLogger(__name__)


class RegistrationService:
    """
    Xử lý logic đăng ký node mới
    Tuân thủ NIST SP 800-207: Mọi node phải được xác thực trước khi cấp quyền
    """

    def __init__(self):
        self.hub_public_key = settings.WIREGUARD_HUB_PUBLIC_KEY
        self.hub_endpoint = settings.WIREGUARD_HUB_ENDPOINT

    def validate_registration_token(self, token: Optional[str]) -> Tuple[bool, str]:
        """
        Xác thực Pre-shared Registration Token
        Trong production, token này được cấp trước bởi Admin
        """
        if not settings.REQUIRE_REGISTRATION_TOKEN:
            return True, "Token validation disabled"

        if not token:
            return False, "Registration token is required"

        # TODO: Implement token storage và validation
        # Có thể dùng Redis với TTL hoặc DB table riêng
        if token == settings.MASTER_REGISTRATION_TOKEN:
            return True, "Valid master token"

        return False, "Invalid registration token"

    def check_duplicate(self, db: Session, hostname: str, public_key: str) -> Tuple[bool, Optional[Node]]:
        """
        Kiểm tra node đã tồn tại chưa
        """
        existing = db.query(Node).filter(
            (Node.hostname == hostname) | (Node.public_key == public_key)
        ).first()

        if existing:
            return True, existing
        return False, None

    def register_node(
        self,
        db: Session,
        request: NodeRegisterRequest,
        client_ip: str
    ) -> Tuple[NodeRegisterResponse, int]:
        """
        Đăng ký node mới vào hệ thống

        Returns:
            Tuple[NodeRegisterResponse, HTTP_STATUS_CODE]
        """
        # 1. Validate registration token
        is_valid, message = self.validate_registration_token(request.registration_token)
        if not is_valid:
            raise PermissionError(message)

        # 2. Check duplicate
        is_duplicate, existing_node = self.check_duplicate(
            db, request.hostname, request.public_key
        )

        if is_duplicate:
            if existing_node.public_key == request.public_key:
                # Cùng key -> có thể là re-register sau reboot
                logger.info(f"Node {request.hostname} re-registering with same key")
                return self._build_response(existing_node), 200
            else:
                raise ValueError(f"Hostname '{request.hostname}' already registered with different key")

        # 3. Create new node record
        new_node = Node(
            hostname=request.hostname,
            role=request.role.value,
            public_key=request.public_key,
            description=request.description,
            real_ip=client_ip,
            agent_version=request.agent_version,
            os_info=request.os_info,
            status=self._determine_initial_status(request.role),
            overlay_ip="",  # Temporary, will be assigned below
        )

        try:
            db.add(new_node)
            db.flush()  # Get node ID without committing

            # 4. Allocate Overlay IP
            overlay_ip = ipam_service.allocate_ip(db, new_node.id)
            if not overlay_ip:
                db.rollback()
                raise RuntimeError("IP Pool exhausted")

            new_node.overlay_ip = overlay_ip
            new_node.last_seen = datetime.utcnow()

            db.commit()
            db.refresh(new_node)

            logger.info(f"Registered new node: {request.hostname} -> {overlay_ip}")

        except IntegrityError as e:
            db.rollback()
            logger.error(f"Database error during registration: {e}")
            raise ValueError("Registration failed due to database constraint")

        return self._build_response(new_node), 201

    def _determine_initial_status(self, role: str) -> str:
        """
        Quyết định status ban đầu dựa trên role
        - OPS: Auto-approve (cần thiết để bootstrap)
        - Others: Pending (cần admin approve)
        """
        if settings.AUTO_APPROVE_ALL:
            return NodeStatus.ACTIVE.value

        if role in ["ops", "hub"]:
            return NodeStatus.ACTIVE.value

        return NodeStatus.PENDING.value

    def _build_response(self, node: Node) -> NodeRegisterResponse:
        """
        Xây dựng response trả về cho Agent
        """
        return NodeRegisterResponse(
            node_id=node.id,
            hostname=node.hostname,
            status=SchemaNodeStatus(node.status),
            overlay_ip=node.overlay_ip,
            server_public_key=self.hub_public_key,
            server_endpoint=self.hub_endpoint,
            dns_servers=settings.DNS_SERVERS,
            allowed_ips=settings.WIREGUARD_ALLOWED_IPS,
            message=f"Registration successful. Status: {node.status}"
        )


# Singleton
registration_service = RegistrationService()
````

---

## 5. API Endpoints

````python
from fastapi import APIRouter, Depends, HTTPException, Request, status
from sqlalchemy.orm import Session
from typing import List
import logging

from database.session import get_db
from schemas.node import (
    NodeRegisterRequest,
    NodeRegisterResponse,
    NodeConfigResponse,
)
from core.registration import registration_service
from core.policy_engine import policy_engine

logger = logging.getLogger(__name__)
router = APIRouter(prefix="/nodes", tags=["nodes"])


@router.post(
    "/register",
    response_model=NodeRegisterResponse,
    status_code=status.HTTP_201_CREATED,
    summary="Register a new node",
    description="""
    Đăng ký node mới vào mạng Zero Trust.

    **Flow:**
    1. Agent sinh WireGuard keypair
    2. Agent gửi public key + hostname + role
    3. Control Plane cấp Overlay IP
    4. Control Plane trả về config để Agent setup WireGuard

    **Security:**
    - Yêu cầu registration_token trong production
    - IP được ghi log để audit
    """
)
async def register_node(
    request: NodeRegisterRequest,
    http_request: Request,
    db: Session = Depends(get_db)
):
    """
    Endpoint đăng ký node mới
    """
    client_ip = http_request.client.host
    logger.info(f"Registration request from {client_ip}: {request.hostname}")

    try:
        response, status_code = registration_service.register_node(
            db=db,
            request=request,
            client_ip=client_ip
        )
        return response

    except PermissionError as e:
        logger.warning(f"Registration denied for {request.hostname}: {e}")
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail=str(e)
        )
    except ValueError as e:
        logger.warning(f"Invalid registration for {request.hostname}: {e}")
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=str(e)
        )
    except RuntimeError as e:
        logger.error(f"Registration error: {e}")
        raise HTTPException(
            status_code=status.HTTP_503_SERVICE_UNAVAILABLE,
            detail=str(e)
        )


@router.get(
    "/config/{hostname}",
    response_model=NodeConfigResponse,
    summary="Get node configuration",
    description="Agent gọi endpoint này để lấy cấu hình WireGuard và ACL rules"
)
async def get_node_config(
    hostname: str,
    http_request: Request,
    db: Session = Depends(get_db)
):
    """
    Trả về cấu hình đầy đủ cho Agent
    """
    from database.models import Node, NodeStatus

    node = db.query(Node).filter(Node.hostname == hostname).first()

    if not node:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Node '{hostname}' not found"
        )

    if node.status != NodeStatus.ACTIVE.value:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail=f"Node status is '{node.status}'. Must be 'active' to get config."
        )

    # Update last_seen và real_ip
    node.last_seen = datetime.utcnow()
    node.real_ip = http_request.client.host
    db.commit()

    # Generate config từ Policy Engine
    config = policy_engine.generate_node_config(db, node)

    return config


@router.post(
    "/heartbeat/{hostname}",
    summary="Node heartbeat",
    description="Agent gọi định kỳ để báo trạng thái"
)
async def heartbeat(
    hostname: str,
    http_request: Request,
    db: Session = Depends(get_db)
):
    from database.models import Node

    node = db.query(Node).filter(Node.hostname == hostname).first()
    if not node:
        raise HTTPException(status_code=404, detail="Node not found")

    node.last_seen = datetime.utcnow()
    node.real_ip = http_request.client.host
    db.commit()

    return {"status": "ok", "timestamp": node.last_seen.isoformat()}


# Import datetime at top
from datetime import datetime
````

---

## 6. Configuration Settings

````python
from pydantic_settings import BaseSettings
from typing import List
import os


class Settings(BaseSettings):
    """
    Cấu hình Control Plane
    Đọc từ biến môi trường hoặc file .env
    """

    # API
    ENV: str = "development"
    API_PORT: int = 8000
    SECRET_KEY: str = "change-me-in-production"

    # Database
    DB_HOST: str = "localhost"
    DB_PORT: int = 5432
    DB_USER: str = "zt_admin"
    DB_PASSWORD: str = "change-me"
    DB_NAME: str = "zt_control_plane"

    @property
    def DATABASE_URL(self) -> str:
        return f"postgresql://{self.DB_USER}:{self.DB_PASSWORD}@{self.DB_HOST}:{self.DB_PORT}/{self.DB_NAME}"

    # WireGuard Hub Configuration
    WIREGUARD_HUB_PUBLIC_KEY: str = "YOUR_HUB_PUBLIC_KEY_HERE"
    WIREGUARD_HUB_ENDPOINT: str = "hub.example.com:51820"
    WIREGUARD_ALLOWED_IPS: str = "10.0.0.0/24"
    WIREGUARD_NETWORK_CIDR: str = "10.0.0.0/24"

    # DNS
    DNS_SERVERS: List[str] = ["10.0.0.1", "1.1.1.1"]

    # Registration Security
    REQUIRE_REGISTRATION_TOKEN: bool = False  # Set True in production
    MASTER_REGISTRATION_TOKEN: str = "change-this-token"
    AUTO_APPROVE_ALL: bool = True  # Set False in production

    class Config:
        env_file = ".env"
        env_file_encoding = "utf-8"


settings = Settings()
````

---

## 7. Ansible Playbook Integration

````yaml
---
# Role: agent
# Cài đặt ZT Agent và đăng ký với Control Plane

- name: Install dependencies
  apt:
    name:
      - wireguard
      - wireguard-tools
      - python3
      - python3-pip
      - curl
    state: present
    update_cache: yes

- name: Create WireGuard directory
  file:
    path: /etc/wireguard
    state: directory
    mode: '0700'

- name: Generate WireGuard private key
  shell: wg genkey
  register: wg_private_key
  args:
    creates: /etc/wireguard/private.key

- name: Save private key
  copy:
    content: "{{ wg_private_key.stdout }}"
    dest: /etc/wireguard/private.key
    mode: '0600'
  when: wg_private_key.changed

- name: Generate WireGuard public key
  shell: cat /etc/wireguard/private.key | wg pubkey
  register: wg_public_key
  changed_when: false

- name: Register with Control Plane
  uri:
    url: "{{ control_plane_url }}/api/v1/nodes/register"
    method: POST
    body_format: json
    body:
      hostname: "{{ inventory_hostname }}"
      role: "{{ node_role }}"
      public_key: "{{ wg_public_key.stdout }}"
      registration_token: "{{ registration_token | default(omit) }}"
      agent_version: "1.0.0"
      os_info: "{{ ansible_distribution }} {{ ansible_distribution_version }}"
    headers:
      Content-Type: "application/json"
    status_code: [200, 201]
    validate_certs: "{{ validate_ssl | default(true) }}"
  register: registration_response

- name: Display assigned Overlay IP
  debug:
    msg: "Node registered successfully. Overlay IP: {{ registration_response.json.overlay_ip }}"

- name: Create WireGuard configuration
  template:
    src: wg0.conf.j2
    dest: /etc/wireguard/wg0.conf
    mode: '0600'
  vars:
    overlay_ip: "{{ registration_response.json.overlay_ip }}"
    server_public_key: "{{ registration_response.json.server_public_key }}"
    server_endpoint: "{{ registration_response.json.server_endpoint }}"
    allowed_ips: "{{ registration_response.json.allowed_ips }}"
    dns_servers: "{{ registration_response.json.dns_servers | join(', ') }}"
  notify: Restart WireGuard

- name: Enable and start WireGuard
  systemd:
    name: wg-quick@wg0
    enabled: yes
    state: started
````

---

## 8. WireGuard Config Template

````jinja2
# WireGuard Configuration
# Generated by Zero Trust Control Plane
# Node: {{ inventory_hostname }}
# Role: {{ node_role }}

[Interface]
PrivateKey = {{ lookup('file', '/etc/wireguard/private.key') }}
Address = {{ overlay_ip }}
DNS = {{ dns_servers }}

# PostUp/PostDown scripts for Zero Trust ACLs
PostUp = /opt/zt-agent/scripts/apply-acl.sh
PostDown = /opt/zt-agent/scripts/remove-acl.sh

[Peer]
# Hub Server
PublicKey = {{ server_public_key }}
Endpoint = {{ server_endpoint }}
AllowedIPs = {{ allowed_ips }}
PersistentKeepalive = 25
````

---

## 9. Ansible Inventory Example

````ini
[control_plane]
vps-1 ansible_host=1.2.3.4 node_role=hub

[app_servers]
vps-2 ansible_host=5.6.7.8 node_role=app
vps-5 ansible_host=9.10.11.12 node_role=app

[db_servers]
vps-3 ansible_host=13.14.15.16 node_role=db

[ops_servers]
vps-4 ansible_host=17.18.19.20 node_role=ops

[agents:children]
app_servers
db_servers
ops_servers

[agents:vars]
control_plane_url=https://hub.example.com
registration_token=your-secure-token-here
validate_ssl=true
````

---

## 10. Main Playbook

````yaml
---
- name: Deploy Zero Trust Agents
  hosts: agents
  become: yes

  vars:
    control_plane_url: "{{ hostvars['vps-1']['control_plane_url'] | default('https://hub.example.com') }}"

  roles:
    - role: agent
````

---

## Workflow tổng quan

```
┌────────────────────────────────────────────────────────────────────────┐
│                         REGISTRATION FLOW                              │
├────────────────────────────────────────────────────────────────────────┤
│                                                                        │
│  1. Ansible chạy trên VPS-2 (Odoo)                                    │
│     └── wg genkey → Public Key: "aB3dE5..."                           │
│                                                                        │
│  2. Ansible gọi POST /api/v1/nodes/register                           │
│     └── Body: {hostname: "odoo-1", role: "app", public_key: "aB3d.."} │
│                                                                        │
│  3. Control Plane:                                                     │
│     ├── Validate token ✓                                              │
│     ├── Check duplicate ✓                                             │
│     ├── IPAM: Allocate 10.0.0.2/24 ✓                                  │
│     ├── Save to DB ✓                                                  │
│     └── Return: {overlay_ip: "10.0.0.2/24", server_key: "xYz..."}    │
│                                                                        │
│  4. Ansible nhận response:                                             │
│     ├── Tạo /etc/wireguard/wg0.conf                                   │
│     └── systemctl enable --now wg-quick@wg0                           │
│                                                                        │
│  5. Agent định kỳ gọi /config và /heartbeat để:                       │
│     ├── Cập nhật danh sách peers                                      │
│     └── Cập nhật ACL rules (iptables)                                 │
│                                                                        │
└────────────────────────────────────────────────────────────────────────┘
```

Thiết kế này tuân thủ **NIST SP 800-207** với các nguyên tắc:
- **Never Trust, Always Verify**: Token authentication
- **Per-session Access**: Mỗi lần sync config là một phiên mới
- **Dynamic Policy**: ACL rules được tính toán realtime từ Policy Engine